pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/utils/math/SafeMath.sol';

contract ValuartMarket is IERC721Receiver, Ownable {
    struct Auction {
        address tokenAddress;
        uint tokenId;
        address payable seller;
        uint  minBid;
        uint time;
        uint endDate;
        address payable highestBidder;
        uint highestBid;
    }
    error CustomError();   
    struct TokenForSale {
        address tokenAddress;
        uint tokenId;
        uint price;
        address payable seller;
        bool approved;
    }

    mapping(address => mapping(uint => Auction)) public auctions;

    mapping(address => mapping(uint => address payable)) public creators;

    mapping(address => mapping(uint => TokenForSale)) public store;

    function createAuction(address tokenAddress, uint tokenId, uint minBid, uint time) external onlyOwner() {
        Auction storage auction = auctions[tokenAddress][tokenId];
        TokenForSale storage tokenForSale = store[tokenAddress][tokenId];

        if (auction.tokenAddress != address(0)) revert('The auction already exist');
        if (tokenForSale.tokenAddress != address(0)) revert('The token is already for sale');

        auction.tokenAddress = tokenAddress;
        auction.tokenId = tokenId;
        auction.seller = payable(msg.sender);
        auction.minBid = minBid;
        auction.time = time;
        auction.endDate = 0;
        auction.highestBidder = payable(address(0));
        auction.highestBid = 0;

        IERC721(tokenAddress).safeTransferFrom(msg.sender, address(this), tokenId);
    }

    function bid(address tokenAddress, uint tokenId) external payable {
        Auction storage auction = auctions[tokenAddress][tokenId];

        if (auction.tokenAddress == address(0)) revert('The auction does not exist.');
        if (auction.endDate != 0 && block.timestamp > auction.endDate) revert('The auction has ended.');

        if (auction.highestBid > 0) {
            if (auction.highestBidder == msg.sender) revert('The user already has the highest bid.');
            if (msg.value <= auction.highestBid && msg.value - auction.highestBid < (100000000 gwei)) revert('The bid amount is too low.');

            if (auction.endDate <= block.timestamp + 15 minutes) {
                auction.endDate += 15 minutes;
            }

            auction.highestBidder.transfer(auction.highestBid);
        } else {
            if (msg.value < auction.minBid) revert('The bid is lower than minimum accepted value.');

            auction.endDate = block.timestamp + auction.time;
        }

        auction.highestBidder = payable(msg.sender);
        auction.highestBid = msg.value;
    }

    function endAuction(address tokenAddress, uint tokenId) external onlyOwner() {
        Auction storage auction = auctions[tokenAddress][tokenId];

        if (auction.tokenAddress == address(0)) revert('The auction does not exist.');
        if (auction.endDate != 0 && block.timestamp < auction.endDate) revert('The auction has not ended.');
        
        uint endDate = auction.endDate;
        address payable seller = auction.seller;
        uint highestBid = auction.highestBid;
        address highestBidder = auction.highestBidder;

        delete auctions[tokenAddress][tokenId];

        if (endDate != 0) {
            address payable tokenCreator = creators[tokenAddress][tokenId];

            if  (tokenCreator == address(0)) {
                creators[tokenAddress][tokenId] = payable(seller);
                seller.transfer(highestBid);
            }

            if (tokenCreator != address(0)) {
                uint royalty = SafeMath.div(highestBid, 10);

                seller.transfer(highestBid - royalty);
                tokenCreator.transfer(royalty);
            }
        }

        IERC721(tokenAddress).safeTransferFrom(address(this), highestBidder, tokenId);
    }

    function sell(address tokenAddress, uint tokenId, uint price) external {
        TokenForSale storage tokenForSale = store[tokenAddress][tokenId];
        Auction storage auction = auctions[tokenAddress][tokenId];

        if (tokenForSale.tokenAddress != address(0)) revert('The token is already for sale.');
        if (auction.tokenAddress != address(0)) revert('The token is already at auction.');

        tokenForSale.tokenAddress = tokenAddress;
        tokenForSale.tokenId = tokenId;
        tokenForSale.price = price;
        tokenForSale.seller = payable(msg.sender);

        address tokenOwner = owner();
        tokenForSale.approved = msg.sender == tokenOwner;

        IERC721(tokenAddress).safeTransferFrom(msg.sender, address(this), tokenId);
    }

    function approveSelling(address tokenAddress, uint tokenId) external onlyOwner() {
        TokenForSale storage tokenForSale = store[tokenAddress][tokenId];

        if (tokenForSale.tokenAddress == address(0)) revert('The token is not for sale.');
        if (tokenForSale.approved) revert('The token is already approved for sell.');

        tokenForSale.approved = true;
    }

    function declineSelling(address tokenAddress, uint tokenId) external onlyOwner() {
        TokenForSale storage tokenForSale = store[tokenAddress][tokenId];

        if (tokenForSale.tokenAddress == address(0)) revert('The token is not for sale.');
        if (tokenForSale.approved) revert('The token is already approved for sell.');
        
        address seller = tokenForSale.seller;

        delete store[tokenAddress][tokenId];

        IERC721(tokenAddress).safeTransferFrom(address(this), seller, tokenId);
    }

    function buy(address tokenAddress, uint tokenId) external payable {
        TokenForSale storage tokenForSale = store[tokenAddress][tokenId];

        if (tokenForSale.tokenAddress == address(0)) revert('The token is not for sale.');
        if (tokenForSale.seller == msg.sender) revert('The user is a seller.');
        if (!tokenForSale.approved) revert('The token is not approved for sell.');
        if (msg.value < tokenForSale.price) revert('Insufficient funds.');

        address payable tokenCreator = creators[tokenAddress][tokenId];
        uint priceDiff = msg.value - tokenForSale.price;
        uint tokenPrice = tokenForSale.price;
        address payable tokenSeller = tokenForSale.seller;
        uint royalty = SafeMath.div(tokenForSale.price, 10);

        if (tokenCreator == address(0)) {
            royalty = 0;
            creators[tokenAddress][tokenId] = tokenSeller;
        }

        delete store[tokenAddress][tokenId];

        tokenCreator.transfer(royalty);

        if (tokenCreator != address(0)) tokenSeller.transfer(tokenPrice - royalty);

        if (priceDiff > 0) {
            payable(msg.sender).transfer(priceDiff);
        }

        IERC721(tokenAddress).safeTransferFrom(address(this), msg.sender, tokenId);
    }

    function removeFromSale(address tokenAddress, uint tokenId) external {
        TokenForSale storage tokenForSale = store[tokenAddress][tokenId];
        address tokenOwner = owner();

        if (tokenForSale.tokenAddress == address(0)) revert('The token is not for sale.');
        if (msg.sender != tokenOwner || msg.sender == tokenForSale.seller) revert('The user is not the owner.');

        IERC721(tokenAddress).safeTransferFrom(address(this), msg.sender, tokenId);
    }

    function onERC721Received(address, address, uint, bytes memory) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }
}