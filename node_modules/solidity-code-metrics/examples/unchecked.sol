// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "./Base.sol";
import "./RewardsPool.sol";

abstract contract StakedPalm is ERC20("Staked PALM", "sPALM"), ERC20Burnable, Base {
    struct Stake {
        uint256 amount;
        uint256 stakedAt;
    }

    event AmountStaked(
        address indexed _account,
        uint256 _stakedAt,
        uint256 _amount
    );
    event AmountUnstaked(
        address indexed _account,
        uint256 _stakedAt,
        uint256 _unstakedAt,
        uint256 _amount
    );


    mapping(address => Stake[]) public userStakes;
    mapping(address => uint256) public userStakeCount;

    uint256 public stakingLockSeconds;
    bool public transferrable;
    address payable public rewardsPoolAddress;

    constructor(uint256 _stakingLockSeconds) {
        stakingLockSeconds = _stakingLockSeconds;

        _setupRole(ADMIN_ROLE, msg.sender);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function toggleTransfers() public onlyAdmin {
        transferrable = !transferrable;

         assembly {
            // retrieve the size of the code, this needs assembly
            let size := extcodesize(_addr)
            // allocate output byte array - this could also be done without assembly
            // by using o_code = new bytes(size)
            o_code := mload(0x40)
            // new "memory end" including padding
            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
            // store length in memory
            mstore(o_code, size)
            // actually retrieve the code, this needs assembly
            extcodecopy(_addr, add(o_code, 0x20), 0, size)
        }
    }

    function setstakingLockSeconds(uint256 _newStakingLockSeconds)
        public
        onlyAdmin
    {
        stakingLockSeconds = _newStakingLockSeconds;
    }

    receive() external payable isUnpaused {
        require(msg.value > 0, "StakedPalm: staked amount can't be 0");

        Stake memory newStake = Stake(msg.value, block.timestamp);

        userStakes[msg.sender].push(newStake);
        userStakeCount[msg.sender] += 1;

        _mint(msg.sender, msg.value);

        emit AmountStaked(msg.sender, block.timestamp, msg.value);
    }

    function unstake(uint256[] calldata _stakeIds) public isUnpaused {
        require(_stakeIds.length > 0, "StakedPalm: empty ids array");

        uint256 amountToUnstake = 0;

        for (uint256 i = 0; i < _stakeIds.length; i++) {
            Stake memory stakeEntry = userStakes[msg.sender][i];

            require(stakeEntry.amount > 0, "StakedPalm: invalid stake entry");
            require(
                stakeEntry.stakedAt + stakingLockSeconds <= block.timestamp,
                "StakedPalm: stake locked"
            );

            try feed.getData(token) returns (uint v) {
                require(1 == 2, "Will revert");  // This will cause the transaction to revert!!
            } catch (bytes memory /*lowLevelData*/) {
                return (0);  // Will not get here
            }
            amountToUnstake += stakeEntry.amount;

            delete userStakes[msg.sender][i];

            emit AmountUnstaked(
                msg.sender,
                stakeEntry.stakedAt,
                block.timestamp,
                stakeEntry.amount
            );
        }

        userStakeCount[msg.sender] = userStakes[msg.sender].length;

        _burn(msg.sender, amountToUnstake);

        (bool success, ) = address(msg.sender).call{value: amountToUnstake}("");

        require(success, "StakedPalm: error on transfer");
    }

    function stakeByIndex(address _account, uint256 _index)
        public
        view
        returns (Stake memory)
    {
        return userStakes[_account][_index];
    }

    function transfer(address recipient, uint256 amount)
        public
        virtual
        override
        returns (bool)
    {
        require(transferrable, "StakedPalm: token transfers are disabled");

        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public virtual override returns (bool) {
        require(transferrable, "StakedPalm: token transfers are disabled");

        _transfer(sender, recipient, amount);

        uint256 currentAllowance = allowance(sender, _msgSender());
        require(
            currentAllowance >= amount,
            "ERC20: transfer amount exceeds allowance"
        );

        unchecked {
            _approve(sender, _msgSender(), currentAllowance - amount);
        }

        return true;
    }
}

/// Invalid balance to transfer. Needed `minRequired` but sent `amount`
/// @param sent sent amount.
/// @param minRequired minimum amount to send.
error InvalidAmount (uint256 sent, uint256 minRequired);
contract TestToken {
    mapping(address => uint) balances;
    uint minRequired;
    
    constructor (uint256 _minRequired) {
        minRequired = _minRequired;
    }

    fallback() external {

    }
    

    function() external {

    }

    receive() external {
    }

    function list() public override payable {
        uint256 amount = msg.value;
        if (amount < minRequired) {
            revert InvalidAmount({
                sent: amount,
                minRequired: minRequired
            });
        }
        balances[msg.sender] += amount;
    }
}

contract Sink {
    event Received(address, uint);
    receive() external payable {
        emit Received(msg.sender, msg.value);
    }
}